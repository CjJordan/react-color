"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validHex = exports.equalHex = exports.equalColorString = exports.equalColorObjects = void 0;

var _ = require("./");

var equalColorObjects = function equalColorObjects(first, second) {
  if (first === second) return true;

  for (var prop in first) {
    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)
    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)
    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,
    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if
    // there is or not), and then as a type TS can iterate over.
    if (first[prop] !== second[prop]) return false;
  }

  return true;
};

exports.equalColorObjects = equalColorObjects;

var equalColorString = function equalColorString(first, second) {
  return first.replace(/\s/g, '') === second.replace(/\s/g, '');
};

exports.equalColorString = equalColorString;

var equalHex = function equalHex(first, second) {
  if (first.toLowerCase() === second.toLowerCase()) return true; // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects

  return equalColorObjects((0, _.hexToRgba)(first), (0, _.hexToRgba)(second));
};

exports.equalHex = equalHex;
var hex3 = /^#?[0-9A-F]{3}$/i;
var hex6 = /^#?[0-9A-F]{6}$/i;

var validHex = function validHex(color) {
  return hex6.test(color) || hex3.test(color);
};

exports.validHex = validHex;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy50cyJdLCJuYW1lcyI6WyJlcXVhbENvbG9yT2JqZWN0cyIsImZpcnN0Iiwic2Vjb25kIiwicHJvcCIsImVxdWFsQ29sb3JTdHJpbmciLCJyZXBsYWNlIiwiZXF1YWxIZXgiLCJ0b0xvd2VyQ2FzZSIsImhleDMiLCJoZXg2IiwidmFsaWRIZXgiLCJjb2xvciIsInRlc3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFHTyxJQUFNQSxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLENBQy9CQyxLQUQrQixFQUUvQkMsTUFGK0IsRUFHbkI7QUFDWixNQUFJRCxLQUFLLEtBQUtDLE1BQWQsRUFBc0IsT0FBTyxJQUFQOztBQUV0QixPQUFLLElBQU1DLElBQVgsSUFBbUJGLEtBQW5CLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUNHQSxLQUFELENBQTZDRSxJQUE3QyxNQUNDRCxNQUFELENBQThDQyxJQUE5QyxDQUZGLEVBSUUsT0FBTyxLQUFQO0FBQ0g7O0FBRUQsU0FBTyxJQUFQO0FBQ0QsQ0FwQk07Ozs7QUFzQkEsSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFDSCxLQUFELEVBQWdCQyxNQUFoQixFQUE0QztBQUMxRSxTQUFPRCxLQUFLLENBQUNJLE9BQU4sQ0FBYyxLQUFkLEVBQXFCLEVBQXJCLE1BQTZCSCxNQUFNLENBQUNHLE9BQVAsQ0FBZSxLQUFmLEVBQXNCLEVBQXRCLENBQXBDO0FBQ0QsQ0FGTTs7OztBQUlBLElBQU1DLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQUNMLEtBQUQsRUFBZ0JDLE1BQWhCLEVBQTRDO0FBQ2xFLE1BQUlELEtBQUssQ0FBQ00sV0FBTixPQUF3QkwsTUFBTSxDQUFDSyxXQUFQLEVBQTVCLEVBQWtELE9BQU8sSUFBUCxDQURnQixDQUdsRTs7QUFDQSxTQUFPUCxpQkFBaUIsQ0FBQyxpQkFBVUMsS0FBVixDQUFELEVBQW1CLGlCQUFVQyxNQUFWLENBQW5CLENBQXhCO0FBQ0QsQ0FMTTs7O0FBT1AsSUFBTU0sSUFBSSxHQUFHLGtCQUFiO0FBQ0EsSUFBTUMsSUFBSSxHQUFHLGtCQUFiOztBQUVPLElBQU1DLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQUNDLEtBQUQ7QUFBQSxTQUN0QkYsSUFBSSxDQUFDRyxJQUFMLENBQVVELEtBQVYsS0FBb0JILElBQUksQ0FBQ0ksSUFBTCxDQUFVRCxLQUFWLENBREU7QUFBQSxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhleFRvUmdiYSB9IGZyb20gJy4vJztcbmltcG9ydCB7IE9iamVjdENvbG9yIH0gZnJvbSAnLi8nO1xuXG5leHBvcnQgY29uc3QgZXF1YWxDb2xvck9iamVjdHMgPSAoXG4gIGZpcnN0OiBPYmplY3RDb2xvcixcbiAgc2Vjb25kOiBPYmplY3RDb2xvcixcbik6IGJvb2xlYW4gPT4ge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkgcmV0dXJuIHRydWU7XG5cbiAgZm9yIChjb25zdCBwcm9wIGluIGZpcnN0KSB7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBhbGxvd3MgZm9yIGEgdHlwZS1zYWZlIGNhbGxpbmcgb2YgdGhpcyBmdW5jdGlvbiAoZmlyc3QgJiBzZWNvbmQgaGF2ZSB0byBiZSBIU0wsIEhTViwgb3IgUkdCKVxuICAgIC8vIHdpdGggdHlwZS11bnNhZmUgaXRlcmF0aW5nIG92ZXIgb2JqZWN0IGtleXMuIFRTIGRvZXMgbm90IGFsbG93IHRoaXMgd2l0aG91dCBhbiBpbmRleCAoYFtrZXk6IHN0cmluZ106IG51bWJlcmApXG4gICAgLy8gb24gYW4gb2JqZWN0IHRvIGRlZmluZSBob3cgaXRlcmF0aW9uIGlzIG5vcm1hbGx5IGRvbmUuIFRvIGVuc3VyZSBleHRyYSBrZXlzIGFyZSBub3QgYWxsb3dlZCBvbiBvdXIgdHlwZXMsXG4gICAgLy8gd2UgbXVzdCBjYXN0IG91ciBvYmplY3QgdG8gdW5rbm93biAoYXMgUkdCIGRlbWFuZHMgYHJgIGJlIGEga2V5LCB3aGlsZSBgUmVjb3JkPHN0cmluZywgeD5gIGRvZXMgbm90IGNhcmUgaWZcbiAgICAvLyB0aGVyZSBpcyBvciBub3QpLCBhbmQgdGhlbiBhcyBhIHR5cGUgVFMgY2FuIGl0ZXJhdGUgb3Zlci5cbiAgICBpZiAoXG4gICAgICAoZmlyc3QgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KVtwcm9wXSAhPT1cbiAgICAgIChzZWNvbmQgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KVtwcm9wXVxuICAgIClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsQ29sb3JTdHJpbmcgPSAoZmlyc3Q6IHN0cmluZywgc2Vjb25kOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIGZpcnN0LnJlcGxhY2UoL1xccy9nLCAnJykgPT09IHNlY29uZC5yZXBsYWNlKC9cXHMvZywgJycpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsSGV4ID0gKGZpcnN0OiBzdHJpbmcsIHNlY29uZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGlmIChmaXJzdC50b0xvd2VyQ2FzZSgpID09PSBzZWNvbmQudG9Mb3dlckNhc2UoKSkgcmV0dXJuIHRydWU7XG5cbiAgLy8gVG8gY29tcGFyZSBjb2xvcnMgbGlrZSBgI0ZGRmAgYW5kIGBmZmZmZmZgIHdlIGNvbnZlcnQgdGhlbSBpbnRvIFJHQiBvYmplY3RzXG4gIHJldHVybiBlcXVhbENvbG9yT2JqZWN0cyhoZXhUb1JnYmEoZmlyc3QpLCBoZXhUb1JnYmEoc2Vjb25kKSk7XG59O1xuXG5jb25zdCBoZXgzID0gL14jP1swLTlBLUZdezN9JC9pO1xuY29uc3QgaGV4NiA9IC9eIz9bMC05QS1GXXs2fSQvaTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkSGV4ID0gKGNvbG9yOiBzdHJpbmcpOiBib29sZWFuID0+XG4gIGhleDYudGVzdChjb2xvcikgfHwgaGV4My50ZXN0KGNvbG9yKTtcbiJdfQ==